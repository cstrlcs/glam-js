# glam-js

<!-- Do not edit this file directly. Edit the template instead: `codegen/templates/docs.eta`. -->

## API Reference

* `BVec` - A 2-dimensional boolean vector. 
  * `FALSE: BVec2` - All false. (false, false..) 
  * `TRUE: BVec2` - All true. (true, true..) 
  * `splat: (v: boolean) => BVec2` - Creates a vector with all elements set to v. 
  * `bitmask: () => number` - Returns a bitmask with the lowest 2 bits set from the elements of BVec2.
A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc. 
  * `any: () => boolean` - Returns true if any of the elements are true, false otherwise. 
  * `all: () => boolean` - Returns true if all the elements are true, false otherwise. 
  * `test: (index: 0 | 1) => boolean` - Tests the value at index. 
  * `set: (index: 0 | 1, value: boolean) => void` - Sets the element at index. 
  * `bitand: (rhs: BVec2) => BVec2` - Performs the & operation. 
  * `bitor: (rhs: BVec2) => BVec2` - Performs the | operation. 
  * `bitxor: (rhs: BVec2) => BVec2` - Performs the ^ operation. 
  * `not: () => BVec2` - Returns the negation. 
  * `eq: (rhs: boolean | BVec2) => boolean` - This method tests for self and other values to be equal, and is used by ==. 
  * `ne: (rhs: boolean | BVec2) => boolean` - This method tests for !=. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

* `BVec` - A 3-dimensional boolean vector. 
  * `FALSE: BVec3` - All false. (false, false..) 
  * `TRUE: BVec3` - All true. (true, true..) 
  * `splat: (v: boolean) => BVec3` - Creates a vector with all elements set to v. 
  * `bitmask: () => number` - Returns a bitmask with the lowest 2 bits set from the elements of BVec3.
A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc. 
  * `any: () => boolean` - Returns true if any of the elements are true, false otherwise. 
  * `all: () => boolean` - Returns true if all the elements are true, false otherwise. 
  * `test: (index: 0 | 1 | 2) => boolean` - Tests the value at index. 
  * `set: (index: 0 | 1 | 2, value: boolean) => void` - Sets the element at index. 
  * `bitand: (rhs: BVec3) => BVec3` - Performs the & operation. 
  * `bitor: (rhs: BVec3) => BVec3` - Performs the | operation. 
  * `bitxor: (rhs: BVec3) => BVec3` - Performs the ^ operation. 
  * `not: () => BVec3` - Returns the negation. 
  * `eq: (rhs: boolean | BVec3) => boolean` - This method tests for self and other values to be equal, and is used by ==. 
  * `ne: (rhs: boolean | BVec3) => boolean` - This method tests for !=. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

* `BVec` - A 4-dimensional boolean vector. 
  * `FALSE: BVec4` - All false. (false, false..) 
  * `TRUE: BVec4` - All true. (true, true..) 
  * `splat: (v: boolean) => BVec4` - Creates a vector with all elements set to v. 
  * `bitmask: () => number` - Returns a bitmask with the lowest 2 bits set from the elements of BVec4.
A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc. 
  * `any: () => boolean` - Returns true if any of the elements are true, false otherwise. 
  * `all: () => boolean` - Returns true if all the elements are true, false otherwise. 
  * `test: (index: 0 | 1 | 2 | 3) => boolean` - Tests the value at index. 
  * `set: (index: 0 | 1 | 2 | 3, value: boolean) => void` - Sets the element at index. 
  * `bitand: (rhs: BVec4) => BVec4` - Performs the & operation. 
  * `bitor: (rhs: BVec4) => BVec4` - Performs the | operation. 
  * `bitxor: (rhs: BVec4) => BVec4` - Performs the ^ operation. 
  * `not: () => BVec4` - Returns the negation. 
  * `eq: (rhs: boolean | BVec4) => boolean` - This method tests for self and other values to be equal, and is used by ==. 
  * `ne: (rhs: boolean | BVec4) => boolean` - This method tests for !=. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

* `Vec` - A 2-dimensional vector. 
  * `ZERO: Vec2` - All zeroes. (0, 0..) 
  * `ONE: Vec2` - All ones. (1, 1..) 
  * `NEG_ONE: Vec2` - All negative ones. (-1, -1..) 
  * `MIN: Vec2` - All `Number.MIN_VALUE`. (5e-324, 5e-324..) 
  * `MAX: Vec2` - All `Number.MAX_VALUE`. (1.7976931348623157e+308, 1.7976931348623157e+308..) 
  * `NAN: Vec2` - All `NaN`. (NaN, NaN..) 
  * `INFINITY: Vec2` - All `Infinity`. (Infinity, Infinity..) 
  * `NEG_INFINITY: Vec2` - All `-Infinity`. (-Infinity, -Infinity..) 
  * `X: Vec2` - A unit vector pointing along the positive X axis. (1, 0) 
  * `Y: Vec2` - A unit vector pointing along the positive Y axis. (0, 1) 
  * `NEG_X: Vec2` - A unit vector pointing along the negative X axis. (-1, 0) 
  * `NEG_Y: Vec2` - A unit vector pointing along the negative Y axis. (0, -1) 
  * `AXES: Vec2[]` - The unit axes. [Vec2.X, Vec2.Y] 
  * `splat: (v: number) => Vec2` - Creates a vector with all elements set to v. (v, v) 
  * `select: (mask: BVec2, ifTrue: Vec2, ifFalse: Vec2) => Vec2` - Creates a vector from the elements in `ifTrue` and `ifFalse`, selecting which to use for each element.
A true element in the mask uses the corresponding element from `ifTrue`, and false uses the element from `ifFalse`. 
  * `fromArray: (a: [number, number]) => Vec2` - Creates a new vector from an array. 
  * `toArray: () => [number, number]` - [x, y] 
  * `dot: (rhs: Vec2) => number` - Computes the dot product of `Vec2` and `rhs`. 
  * `dotIntoVec: (rhs: Vec2) => Vec2` - Returns a vector where every component is the dot product of `Vec3` and `rhs`. 
  * `min: (rhs: Vec2) => Vec2` - Returns a vector containing the minimum values for each element of `Vec2` and `rhs`.
In other words this computes `Math.min(this.x, rhs.x), Math.min(this.y, rhs.y)..`. 
  * `max: (rhs: Vec2) => Vec2` - Returns a vector containing the maximum values for each element of `Vec2` and `rhs`.
In other words this computes `Math.max(this.x, rhs.x), Math.max(this.y, rhs.y)..`. 
  * `clamp: (min: Vec2, max: Vec2) => Vec2` - Component-wise clamping of values. 
  * `minElement: () => number` - Returns the horizontal minimum of `Vec2`.
In other words this computes `Math.min(x, y..)`. 
  * `maxElement: () => number` - Returns the horizontal maximum of `Vec2`.
In other words this computes `Math.max(x, y, ..)`. 
  * `cmpeq: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `==` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x == rhs.x, this.y == rhs.y..]` for all elements. 
  * `cmpne: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `!=` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x != rhs.x, this.y != rhs.y..]` for all elements. 
  * `cmpge: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `>=` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x >= rhs.x, this.y >= rhs.y..]` for all elements. 
  * `cmpgt: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `>` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x > rhs.x, this.y > rhs.y..]` for all elements. 
  * `cmple: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `<=` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x <= rhs.x, this.y <= rhs.y..]` for all elements. 
  * `cmplt: (rhs: Vec2) => BVec2` - Returns a vector mask containing the result of a `<` comparison for each element of `Vec2` and `rhs`.
In other words this computes `[this.x < rhs.x, this.y < rhs.y..]` for all elements. 
  * `abs: () => Vec2` - Returns a vector containing the absolute value of each element of `Vec3`. 
  * `signum: () => Vec2` - Returns a vector with elements representing the sign of `Vec2`.
- `1` if the number is positive, `+0` or `INFINITY`
- `-1` if the number is negative, `-0` or `NEG_INFINITY` 
  * `isNegativeBitmask: () => number` - Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `Vec2`.
A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
into the first lowest bit, element `y` into the second, etc. 
  * `isFinite: () => boolean` - Returns `true` if, and only if, all elements are finite. If any element is either `NaN`, positive or negative infinity, this will return `false`. 
  * `isNaN: () => boolean` - Returns `true` if any elements are `NaN`. 
  * `isNaNMask: () => BVec2` - Performs `isNaN` on each element of  returning a vector mask of the results.
In other words, this computes `[Number.isNaN(x), Number.isNaN(y)..]`. 
  * `length: () => number` - Computes the length of `Vec2`. 
  * `lengthSquared: () => number` - Computes the squared length of `Vec2`.
This is faster than `length()` as it avoids a square root operation. 
  * `lengthRecip: () => number` - Computes `1 / length()`.
For valid results, `Vec2` must _not_ be of length zero. 
  * `distance: (rhs: Vec2) => number` - Computes the Euclidean distance between two points in space. 
  * `distanceSquared: (rhs: Vec2) => number` - Compute the squared euclidean distance between two points in space. 
  * `divEuclid: (rhs: Vec2) => Vec2` - Returns the element-wise quotient of [Euclidean division] of `Vec2` by `rhs`. 
  * `remEuclid: (rhs: Vec2) => Vec2` - Returns the element-wise remainder of [Euclidean division] of `Vec2` by `rhs`. 
  * `normalize: () => Vec2` - Returns `Vec2` normalized to length 1.
For valid results, `Vec2` must _not_ be of length zero, nor very close to zero. 
  * `normalizeOrZero: () => Vec2` - Returns `Vec2` normalized to length 1 if possible, else returns zero.
In particular, if the input is zero (or very close to zero), or non-finite,
the result of this operation will be zero. 
  * `isNormalized: () => boolean` - Returns whether `Vec2` is length `1` or not.
Uses a precision threshold of `1e-4`. 
  * `projectOnto: (rhs: Vec2) => Vec2` - Returns the vector projection of `Vec2` onto `rhs`.
`rhs` must be of non-zero length. 
  * `rejectFrom: (rhs: Vec2) => Vec2` - Returns the vector rejection of `Vec2` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec2` onto
`rhs`, in rhs words the result of `Vec2 - this.project_onto(rhs)`.
`rhs` must be of non-zero length. 
  * `projectOntoNormalized: (rhs: Vec2) => Vec2` - Returns the vector projection of `Vec2` onto `rhs`.
`rhs` must be normalized. 
  * `rejectFromNormalized: (rhs: Vec2) => Vec2` - Returns the vector rejection of `Vec2` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec2` onto
`rhs`, in rhs words the result of `Vec2.sub(this.projectOnto(rhs))`.
`rhs` must be normalized. 
  * `round: () => Vec2` - Returns a vector containing the nearest integer to a number for each element of `Vec2`.
Round half-way cases away from 0. 
  * `floor: () => Vec2` - Returns a vector containing the largest integer less than or equal to a number for each
element of `Vec2`. 
  * `ceil: () => Vec2` - Returns a vector containing the smallest integer greater than or equal to a number for
each element of `Vec2`. 
  * `trunc: () => Vec2` - Returns a vector containing the integer part each element of `Vec2`. This means numbers are
always truncated towards zero. 
  * `fract: () => Vec2` - Returns a vector containing the fractional part of the vector, e.g. `Vec2 -
this.floor()`.
Note that this is fast but not precise for large numbers. 
  * `exp: () => Vec2` - Returns a vector containing `e^Vec2` (the exponential function) for each element of `Vec2`. 
  * `powf: (n: number) => Vec2` - Returns a vector containing each element of `Vec2` raised to the power of `n`. 
  * `recip: () => Vec2` - Returns a vector containing the reciprocal `1/n` of each element of `Vec2`. 
  * `lerp: (rhs: Vec2, s: number) => Vec2` - Performs a linear interpolation between `Vec2` and `rhs` based on the value `s`.
When `s` is `0`, the result will be equal to `Vec2`.  When `s` is `1`, the result
will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
extrapolated. 
  * `midpoint: (rhs: Vec2) => Vec2` - Calculates the midpoint between `Vec2` and `rhs`.
The midpoint is the average of, or halfway point between, two vectors.
`a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
while being slightly cheaper to compute. 
  * `absDiffEq: (rhs: Vec2, maxAbsDiff: number) => boolean` - Returns true if the absolute difference of all elements between `Vec2` and `rhs` is
less than or equal to `maxAbsDiff`.
This can be used to compare if two vectors contain similar elements. It works best when
comparing with a known value. The `maxAbsDiff` that should be used used depends on
the values being compared against.
For more see
[comparing floating point numbers](https:/**randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/). 
  * `clampLength: (min: number, max: number) => Vec2` - Returns a vector with a length no less than `min` and no more than `max`. 
  * `clampLengthMax: (max: number) => Vec2` - Returns a vector with a length no more than `max`. 
  * `clampLengthMin: (min: number) => Vec2` - Returns a vector with a length no less than `min`. 
  * `mulAdd: (a: Vec2, b: Vec2) => Vec2` - Fused multiply-add. Computes `(Vec2 * a) + b` element-wise with only one rounding
error, yielding a more accurate result than an unfused multiply-add. 
  * `fromAngle: (angle: number) => Vec2` - Creates a 2D vector containing `[Math.cos(angle), Math.sin(angle)]`. This can be used in
conjunction with the [`rotate()`][Vec2.rotate()] method, e.g.
`Vec2.fromAngle(PI).rotate(Vector.Y)` will create the vector `[-1, 0]`
and rotate [`Vector.Y`] around it returning `Vector.Y.neg()`. 
  * `toAngle: () => number` - Returns the angle (in radians) of this vector in the range `[-π, +π]`.
The input does not need to be a unit vector however it must be non-zero. 
  * `angleBetween: (rhs: Vec2) => number` - Returns the angle (in radians) between `Vec2` and `rhs` in the range `[-π, +π]`.
The inputs do not need to be unit vectors however they must be non-zero. 
  * `perp: () => Vec2` - Returns a vector that is equal to `Vec2` rotated by 90 degrees. 
  * `perpDot: (rhs: Vec2) => number` - The perpendicular dot product of `Vec2` and `rhs`.
Also known as the wedge product, 2D cross product, and determinant. 
  * `rotate: (rhs: Vec2) => Vec2` - Returns `rhs` rotated by the angle of `Vec2`. If `Vec2` is normalized,
then this just rotation. This is what you usually want. Otherwise,
it will be like a rotation with a multiplication by `Vec2`'s length. 
  * `div: (rhs: number | Vec2) => Vec2` - Divides a Vec2 by another Vector, or by a number
(this.x / rhs.x, this.y / rhs.y) or (this.x / rhs, this.y / rhs). 
  * `mul: (rhs: number | Vec2) => Vec2` - Multiplies a Vec2 by another Vector, or by a number
(this.x * rhs.x, this.y * rhs.y..) or (this.x * rhs, this.y * rhs..). 
  * `add: (rhs: number | Vec2) => Vec2` - Sums a Vec2 by another Vector, or by a number
(this.x + rhs.x, this.y + rhs.y..) or (this.x + rhs, this.y + rhs..) 
  * `sub: (rhs: number | Vec2) => Vec2` - Subtracts a Vec2 by another Vector, or by a number
(this.x - rhs.x, this.y - rhs.y..) or (this.x - rhs, this.y - rhs..) 
  * `rem: (rhs: number | Vec2) => Vec2` - Divides a Vec2 by another Vector, or by a number and return its remainder
(this.x % rhs.x, this.y % rhs.y..) or (this.x % rhs, this.y % rhs..) 
  * `neg: () => Vec2` - Returns (-this.x, -this.y..) 
  * `eq: (rhs: number | Vec2) => boolean` - Compares if the vector is equal to another. 
  * `ne: (rhs: number | Vec2) => boolean` - Compares if the vector is not equal to another. 
  * `approxEq: (rhs: number | Vec2) => boolean` - Compares if the vector is approximately equal to another, by the threshold of 1e-6. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

* `Vec` - A 3-dimensional vector. 
  * `ZERO: Vec3` - All zeroes. (0, 0..) 
  * `ONE: Vec3` - All ones. (1, 1..) 
  * `NEG_ONE: Vec3` - All negative ones. (-1, -1..) 
  * `MIN: Vec3` - All `Number.MIN_VALUE`. (5e-324, 5e-324..) 
  * `MAX: Vec3` - All `Number.MAX_VALUE`. (1.7976931348623157e+308, 1.7976931348623157e+308..) 
  * `NAN: Vec3` - All `NaN`. (NaN, NaN..) 
  * `INFINITY: Vec3` - All `Infinity`. (Infinity, Infinity..) 
  * `NEG_INFINITY: Vec3` - All `-Infinity`. (-Infinity, -Infinity..) 
  * `X: Vec3` - A unit vector pointing along the positive X axis. (1, 0, 0) 
  * `Y: Vec3` - A unit vector pointing along the positive Y axis. (0, 1, 0) 
  * `Z: Vec3` - A unit vector pointing along the positive Z axis. (0, 0, 1) 
  * `NEG_X: Vec3` - A unit vector pointing along the negative X axis. (-1, 0, 0) 
  * `NEG_Y: Vec3` - A unit vector pointing along the negative Y axis. (0, -1, 0) 
  * `NEG_Z: Vec3` - A unit vector pointing along the negative Z axis. (0, 0, -1) 
  * `AXES: Vec3[]` - The unit axes. [Vec3.X, Vec3.Y, Vec3.Z] 
  * `splat: (v: number) => Vec3` - Creates a vector with all elements set to v. (v, v, v) 
  * `select: (mask: BVec3, ifTrue: Vec3, ifFalse: Vec3) => Vec3` - Creates a vector from the elements in `ifTrue` and `ifFalse`, selecting which to use for each element.
A true element in the mask uses the corresponding element from `ifTrue`, and false uses the element from `ifFalse`. 
  * `fromArray: (a: [number, number, number]) => Vec3` - Creates a new vector from an array. 
  * `toArray: () => [number, number, number]` - [x, y, z] 
  * `dot: (rhs: Vec3) => number` - Computes the dot product of `Vec3` and `rhs`. 
  * `dotIntoVec: (rhs: Vec3) => Vec3` - Returns a vector where every component is the dot product of `Vec3` and `rhs`. 
  * `cross: (rhs: Vec3) => Vec3` - Computes the cross product of `Vec3` and `rhs`. 
  * `min: (rhs: Vec3) => Vec3` - Returns a vector containing the minimum values for each element of `Vec3` and `rhs`.
In other words this computes `Math.min(this.x, rhs.x), Math.min(this.y, rhs.y)..`. 
  * `max: (rhs: Vec3) => Vec3` - Returns a vector containing the maximum values for each element of `Vec3` and `rhs`.
In other words this computes `Math.max(this.x, rhs.x), Math.max(this.y, rhs.y)..`. 
  * `clamp: (min: Vec3, max: Vec3) => Vec3` - Component-wise clamping of values. 
  * `minElement: () => number` - Returns the horizontal minimum of `Vec3`.
In other words this computes `Math.min(x, y..)`. 
  * `maxElement: () => number` - Returns the horizontal maximum of `Vec3`.
In other words this computes `Math.max(x, y, ..)`. 
  * `cmpeq: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `==` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x == rhs.x, this.y == rhs.y..]` for all elements. 
  * `cmpne: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `!=` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x != rhs.x, this.y != rhs.y..]` for all elements. 
  * `cmpge: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `>=` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x >= rhs.x, this.y >= rhs.y..]` for all elements. 
  * `cmpgt: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `>` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x > rhs.x, this.y > rhs.y..]` for all elements. 
  * `cmple: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `<=` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x <= rhs.x, this.y <= rhs.y..]` for all elements. 
  * `cmplt: (rhs: Vec3) => BVec3` - Returns a vector mask containing the result of a `<` comparison for each element of `Vec3` and `rhs`.
In other words this computes `[this.x < rhs.x, this.y < rhs.y..]` for all elements. 
  * `abs: () => Vec3` - Returns a vector containing the absolute value of each element of `Vec3`. 
  * `signum: () => Vec3` - Returns a vector with elements representing the sign of `Vec3`.
- `1` if the number is positive, `+0` or `INFINITY`
- `-1` if the number is negative, `-0` or `NEG_INFINITY` 
  * `isNegativeBitmask: () => number` - Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `Vec3`.
A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
into the first lowest bit, element `y` into the second, etc. 
  * `isFinite: () => boolean` - Returns `true` if, and only if, all elements are finite. If any element is either `NaN`, positive or negative infinity, this will return `false`. 
  * `isNaN: () => boolean` - Returns `true` if any elements are `NaN`. 
  * `isNaNMask: () => BVec3` - Performs `isNaN` on each element of  returning a vector mask of the results.
In other words, this computes `[Number.isNaN(x), Number.isNaN(y)..]`. 
  * `length: () => number` - Computes the length of `Vec3`. 
  * `lengthSquared: () => number` - Computes the squared length of `Vec3`.
This is faster than `length()` as it avoids a square root operation. 
  * `lengthRecip: () => number` - Computes `1 / length()`.
For valid results, `Vec3` must _not_ be of length zero. 
  * `distance: (rhs: Vec3) => number` - Computes the Euclidean distance between two points in space. 
  * `distanceSquared: (rhs: Vec3) => number` - Compute the squared euclidean distance between two points in space. 
  * `divEuclid: (rhs: Vec3) => Vec3` - Returns the element-wise quotient of [Euclidean division] of `Vec3` by `rhs`. 
  * `remEuclid: (rhs: Vec3) => Vec3` - Returns the element-wise remainder of [Euclidean division] of `Vec3` by `rhs`. 
  * `normalize: () => Vec3` - Returns `Vec3` normalized to length 1.
For valid results, `Vec3` must _not_ be of length zero, nor very close to zero. 
  * `normalizeOrZero: () => Vec3` - Returns `Vec3` normalized to length 1 if possible, else returns zero.
In particular, if the input is zero (or very close to zero), or non-finite,
the result of this operation will be zero. 
  * `isNormalized: () => boolean` - Returns whether `Vec3` is length `1` or not.
Uses a precision threshold of `1e-4`. 
  * `projectOnto: (rhs: Vec3) => Vec3` - Returns the vector projection of `Vec3` onto `rhs`.
`rhs` must be of non-zero length. 
  * `rejectFrom: (rhs: Vec3) => Vec3` - Returns the vector rejection of `Vec3` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec3` onto
`rhs`, in rhs words the result of `Vec3 - this.project_onto(rhs)`.
`rhs` must be of non-zero length. 
  * `projectOntoNormalized: (rhs: Vec3) => Vec3` - Returns the vector projection of `Vec3` onto `rhs`.
`rhs` must be normalized. 
  * `rejectFromNormalized: (rhs: Vec3) => Vec3` - Returns the vector rejection of `Vec3` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec3` onto
`rhs`, in rhs words the result of `Vec3.sub(this.projectOnto(rhs))`.
`rhs` must be normalized. 
  * `round: () => Vec3` - Returns a vector containing the nearest integer to a number for each element of `Vec3`.
Round half-way cases away from 0. 
  * `floor: () => Vec3` - Returns a vector containing the largest integer less than or equal to a number for each
element of `Vec3`. 
  * `ceil: () => Vec3` - Returns a vector containing the smallest integer greater than or equal to a number for
each element of `Vec3`. 
  * `trunc: () => Vec3` - Returns a vector containing the integer part each element of `Vec3`. This means numbers are
always truncated towards zero. 
  * `fract: () => Vec3` - Returns a vector containing the fractional part of the vector, e.g. `Vec3 -
this.floor()`.
Note that this is fast but not precise for large numbers. 
  * `exp: () => Vec3` - Returns a vector containing `e^Vec3` (the exponential function) for each element of `Vec3`. 
  * `powf: (n: number) => Vec3` - Returns a vector containing each element of `Vec3` raised to the power of `n`. 
  * `recip: () => Vec3` - Returns a vector containing the reciprocal `1/n` of each element of `Vec3`. 
  * `lerp: (rhs: Vec3, s: number) => Vec3` - Performs a linear interpolation between `Vec3` and `rhs` based on the value `s`.
When `s` is `0`, the result will be equal to `Vec3`.  When `s` is `1`, the result
will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
extrapolated. 
  * `midpoint: (rhs: Vec3) => Vec3` - Calculates the midpoint between `Vec3` and `rhs`.
The midpoint is the average of, or halfway point between, two vectors.
`a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
while being slightly cheaper to compute. 
  * `absDiffEq: (rhs: Vec3, maxAbsDiff: number) => boolean` - Returns true if the absolute difference of all elements between `Vec3` and `rhs` is
less than or equal to `maxAbsDiff`.
This can be used to compare if two vectors contain similar elements. It works best when
comparing with a known value. The `maxAbsDiff` that should be used used depends on
the values being compared against.
For more see
[comparing floating point numbers](https:/**randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/). 
  * `clampLength: (min: number, max: number) => Vec3` - Returns a vector with a length no less than `min` and no more than `max`. 
  * `clampLengthMax: (max: number) => Vec3` - Returns a vector with a length no more than `max`. 
  * `clampLengthMin: (min: number) => Vec3` - Returns a vector with a length no less than `min`. 
  * `mulAdd: (a: Vec3, b: Vec3) => Vec3` - Fused multiply-add. Computes `(Vec3 * a) + b` element-wise with only one rounding
error, yielding a more accurate result than an unfused multiply-add. 
  * `angleBetween: (rhs: Vec3) => number` - Returns the angle (in radians) between `Vec3` and `rhs` in the range `[-π, +π]`.
The inputs do not need to be unit vectors however they must be non-zero. 
  * `anyOrthogonalVector: () => Vec3` - Returns some vector that is orthogonal to the given one.
The input vector must be finite and non-zero.
The output vector is not necessarily unit length. For that use [`anyOrthonormalVector()`] instead. 
  * `anyOrthonormalVector: () => Vec3` - Returns any unit vector that is orthogonal to the given one.
The input vector must be unit length. 
  * `anyOrthonormalPair: () => Vec3[]` - Given a unit vector return two other vectors that together form an orthonormal
basis. That is, all three vectors are orthogonal to each other and are normalized. 
  * `div: (rhs: number | Vec3) => Vec3` - Divides a Vec3 by another Vector, or by a number
(this.x / rhs.x, this.y / rhs.y) or (this.x / rhs, this.y / rhs). 
  * `mul: (rhs: number | Vec3) => Vec3` - Multiplies a Vec3 by another Vector, or by a number
(this.x * rhs.x, this.y * rhs.y..) or (this.x * rhs, this.y * rhs..). 
  * `add: (rhs: number | Vec3) => Vec3` - Sums a Vec3 by another Vector, or by a number
(this.x + rhs.x, this.y + rhs.y..) or (this.x + rhs, this.y + rhs..) 
  * `sub: (rhs: number | Vec3) => Vec3` - Subtracts a Vec3 by another Vector, or by a number
(this.x - rhs.x, this.y - rhs.y..) or (this.x - rhs, this.y - rhs..) 
  * `rem: (rhs: number | Vec3) => Vec3` - Divides a Vec3 by another Vector, or by a number and return its remainder
(this.x % rhs.x, this.y % rhs.y..) or (this.x % rhs, this.y % rhs..) 
  * `neg: () => Vec3` - Returns (-this.x, -this.y..) 
  * `eq: (rhs: number | Vec3) => boolean` - Compares if the vector is equal to another. 
  * `ne: (rhs: number | Vec3) => boolean` - Compares if the vector is not equal to another. 
  * `approxEq: (rhs: number | Vec3) => boolean` - Compares if the vector is approximately equal to another, by the threshold of 1e-6. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

* `Vec` - A 4-dimensional vector. 
  * `ZERO: Vec4` - All zeroes. (0, 0..) 
  * `ONE: Vec4` - All ones. (1, 1..) 
  * `NEG_ONE: Vec4` - All negative ones. (-1, -1..) 
  * `MIN: Vec4` - All `Number.MIN_VALUE`. (5e-324, 5e-324..) 
  * `MAX: Vec4` - All `Number.MAX_VALUE`. (1.7976931348623157e+308, 1.7976931348623157e+308..) 
  * `NAN: Vec4` - All `NaN`. (NaN, NaN..) 
  * `INFINITY: Vec4` - All `Infinity`. (Infinity, Infinity..) 
  * `NEG_INFINITY: Vec4` - All `-Infinity`. (-Infinity, -Infinity..) 
  * `X: Vec4` - A unit vector pointing along the positive X axis. (1, 0, 0, 0) 
  * `Y: Vec4` - A unit vector pointing along the positive Y axis. (0, 1, 0, 0) 
  * `Z: Vec4` - A unit vector pointing along the positive Z axis. (0, 0, 1, 0) 
  * `W: Vec4` - A unit vector pointing along the positive W axis. (0, 0, 0, 1) 
  * `NEG_X: Vec4` - A unit vector pointing along the negative X axis. (-1, 0, 0, 0) 
  * `NEG_Y: Vec4` - A unit vector pointing along the negative Y axis. (0, -1, 0, 0) 
  * `NEG_Z: Vec4` - A unit vector pointing along the negative Z axis. (0, 0, -1, 0) 
  * `NEG_W: Vec4` - A unit vector pointing along the negative W axis. (0, 0, 0, -1) 
  * `AXES: Vec4[]` - The unit axes. [Vec4.X, Vec4.Y, Vec4.Z, Vec4.W] 
  * `splat: (v: number) => Vec4` - Creates a vector with all elements set to v. (v, v, v, v) 
  * `select: (mask: BVec4, ifTrue: Vec4, ifFalse: Vec4) => Vec4` - Creates a vector from the elements in `ifTrue` and `ifFalse`, selecting which to use for each element.
A true element in the mask uses the corresponding element from `ifTrue`, and false uses the element from `ifFalse`. 
  * `fromArray: (a: [number, number, number, number]) => Vec4` - Creates a new vector from an array. 
  * `toArray: () => [number, number, number, number]` - [x, y, z, w] 
  * `dot: (rhs: Vec4) => number` - Computes the dot product of `Vec4` and `rhs`. 
  * `dotIntoVec: (rhs: Vec4) => Vec4` - Returns a vector where every component is the dot product of `Vec3` and `rhs`. 
  * `min: (rhs: Vec4) => Vec4` - Returns a vector containing the minimum values for each element of `Vec4` and `rhs`.
In other words this computes `Math.min(this.x, rhs.x), Math.min(this.y, rhs.y)..`. 
  * `max: (rhs: Vec4) => Vec4` - Returns a vector containing the maximum values for each element of `Vec4` and `rhs`.
In other words this computes `Math.max(this.x, rhs.x), Math.max(this.y, rhs.y)..`. 
  * `clamp: (min: Vec4, max: Vec4) => Vec4` - Component-wise clamping of values. 
  * `minElement: () => number` - Returns the horizontal minimum of `Vec4`.
In other words this computes `Math.min(x, y..)`. 
  * `maxElement: () => number` - Returns the horizontal maximum of `Vec4`.
In other words this computes `Math.max(x, y, ..)`. 
  * `cmpeq: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `==` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x == rhs.x, this.y == rhs.y..]` for all elements. 
  * `cmpne: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `!=` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x != rhs.x, this.y != rhs.y..]` for all elements. 
  * `cmpge: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `>=` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x >= rhs.x, this.y >= rhs.y..]` for all elements. 
  * `cmpgt: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `>` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x > rhs.x, this.y > rhs.y..]` for all elements. 
  * `cmple: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `<=` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x <= rhs.x, this.y <= rhs.y..]` for all elements. 
  * `cmplt: (rhs: Vec4) => BVec4` - Returns a vector mask containing the result of a `<` comparison for each element of `Vec4` and `rhs`.
In other words this computes `[this.x < rhs.x, this.y < rhs.y..]` for all elements. 
  * `abs: () => Vec4` - Returns a vector containing the absolute value of each element of `Vec3`. 
  * `signum: () => Vec4` - Returns a vector with elements representing the sign of `Vec4`.
- `1` if the number is positive, `+0` or `INFINITY`
- `-1` if the number is negative, `-0` or `NEG_INFINITY` 
  * `isNegativeBitmask: () => number` - Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `Vec4`.
A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
into the first lowest bit, element `y` into the second, etc. 
  * `isFinite: () => boolean` - Returns `true` if, and only if, all elements are finite. If any element is either `NaN`, positive or negative infinity, this will return `false`. 
  * `isNaN: () => boolean` - Returns `true` if any elements are `NaN`. 
  * `isNaNMask: () => BVec4` - Performs `isNaN` on each element of  returning a vector mask of the results.
In other words, this computes `[Number.isNaN(x), Number.isNaN(y)..]`. 
  * `length: () => number` - Computes the length of `Vec4`. 
  * `lengthSquared: () => number` - Computes the squared length of `Vec4`.
This is faster than `length()` as it avoids a square root operation. 
  * `lengthRecip: () => number` - Computes `1 / length()`.
For valid results, `Vec4` must _not_ be of length zero. 
  * `distance: (rhs: Vec4) => number` - Computes the Euclidean distance between two points in space. 
  * `distanceSquared: (rhs: Vec4) => number` - Compute the squared euclidean distance between two points in space. 
  * `divEuclid: (rhs: Vec4) => Vec4` - Returns the element-wise quotient of [Euclidean division] of `Vec4` by `rhs`. 
  * `remEuclid: (rhs: Vec4) => Vec4` - Returns the element-wise remainder of [Euclidean division] of `Vec4` by `rhs`. 
  * `normalize: () => Vec4` - Returns `Vec4` normalized to length 1.
For valid results, `Vec4` must _not_ be of length zero, nor very close to zero. 
  * `normalizeOrZero: () => Vec4` - Returns `Vec4` normalized to length 1 if possible, else returns zero.
In particular, if the input is zero (or very close to zero), or non-finite,
the result of this operation will be zero. 
  * `isNormalized: () => boolean` - Returns whether `Vec4` is length `1` or not.
Uses a precision threshold of `1e-4`. 
  * `projectOnto: (rhs: Vec4) => Vec4` - Returns the vector projection of `Vec4` onto `rhs`.
`rhs` must be of non-zero length. 
  * `rejectFrom: (rhs: Vec4) => Vec4` - Returns the vector rejection of `Vec4` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec4` onto
`rhs`, in rhs words the result of `Vec4 - this.project_onto(rhs)`.
`rhs` must be of non-zero length. 
  * `projectOntoNormalized: (rhs: Vec4) => Vec4` - Returns the vector projection of `Vec4` onto `rhs`.
`rhs` must be normalized. 
  * `rejectFromNormalized: (rhs: Vec4) => Vec4` - Returns the vector rejection of `Vec4` from `rhs`.
The vector rejection is the vector perpendicular to the projection of `Vec4` onto
`rhs`, in rhs words the result of `Vec4.sub(this.projectOnto(rhs))`.
`rhs` must be normalized. 
  * `round: () => Vec4` - Returns a vector containing the nearest integer to a number for each element of `Vec4`.
Round half-way cases away from 0. 
  * `floor: () => Vec4` - Returns a vector containing the largest integer less than or equal to a number for each
element of `Vec4`. 
  * `ceil: () => Vec4` - Returns a vector containing the smallest integer greater than or equal to a number for
each element of `Vec4`. 
  * `trunc: () => Vec4` - Returns a vector containing the integer part each element of `Vec4`. This means numbers are
always truncated towards zero. 
  * `fract: () => Vec4` - Returns a vector containing the fractional part of the vector, e.g. `Vec4 -
this.floor()`.
Note that this is fast but not precise for large numbers. 
  * `exp: () => Vec4` - Returns a vector containing `e^Vec4` (the exponential function) for each element of `Vec4`. 
  * `powf: (n: number) => Vec4` - Returns a vector containing each element of `Vec4` raised to the power of `n`. 
  * `recip: () => Vec4` - Returns a vector containing the reciprocal `1/n` of each element of `Vec4`. 
  * `lerp: (rhs: Vec4, s: number) => Vec4` - Performs a linear interpolation between `Vec4` and `rhs` based on the value `s`.
When `s` is `0`, the result will be equal to `Vec4`.  When `s` is `1`, the result
will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
extrapolated. 
  * `midpoint: (rhs: Vec4) => Vec4` - Calculates the midpoint between `Vec4` and `rhs`.
The midpoint is the average of, or halfway point between, two vectors.
`a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
while being slightly cheaper to compute. 
  * `absDiffEq: (rhs: Vec4, maxAbsDiff: number) => boolean` - Returns true if the absolute difference of all elements between `Vec4` and `rhs` is
less than or equal to `maxAbsDiff`.
This can be used to compare if two vectors contain similar elements. It works best when
comparing with a known value. The `maxAbsDiff` that should be used used depends on
the values being compared against.
For more see
[comparing floating point numbers](https:/**randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/). 
  * `clampLength: (min: number, max: number) => Vec4` - Returns a vector with a length no less than `min` and no more than `max`. 
  * `clampLengthMax: (max: number) => Vec4` - Returns a vector with a length no more than `max`. 
  * `clampLengthMin: (min: number) => Vec4` - Returns a vector with a length no less than `min`. 
  * `mulAdd: (a: Vec4, b: Vec4) => Vec4` - Fused multiply-add. Computes `(Vec4 * a) + b` element-wise with only one rounding
error, yielding a more accurate result than an unfused multiply-add. 
  * `angleBetween: (rhs: Vec4) => number` - Returns the angle (in radians) between `Vec4` and `rhs` in the range `[-π, +π]`.
The inputs do not need to be unit vectors however they must be non-zero. 
  * `div: (rhs: number | Vec4) => Vec4` - Divides a Vec4 by another Vector, or by a number
(this.x / rhs.x, this.y / rhs.y) or (this.x / rhs, this.y / rhs). 
  * `mul: (rhs: number | Vec4) => Vec4` - Multiplies a Vec4 by another Vector, or by a number
(this.x * rhs.x, this.y * rhs.y..) or (this.x * rhs, this.y * rhs..). 
  * `add: (rhs: number | Vec4) => Vec4` - Sums a Vec4 by another Vector, or by a number
(this.x + rhs.x, this.y + rhs.y..) or (this.x + rhs, this.y + rhs..) 
  * `sub: (rhs: number | Vec4) => Vec4` - Subtracts a Vec4 by another Vector, or by a number
(this.x - rhs.x, this.y - rhs.y..) or (this.x - rhs, this.y - rhs..) 
  * `rem: (rhs: number | Vec4) => Vec4` - Divides a Vec4 by another Vector, or by a number and return its remainder
(this.x % rhs.x, this.y % rhs.y..) or (this.x % rhs, this.y % rhs..) 
  * `neg: () => Vec4` - Returns (-this.x, -this.y..) 
  * `eq: (rhs: number | Vec4) => boolean` - Compares if the vector is equal to another. 
  * `ne: (rhs: number | Vec4) => boolean` - Compares if the vector is not equal to another. 
  * `approxEq: (rhs: number | Vec4) => boolean` - Compares if the vector is approximately equal to another, by the threshold of 1e-6. 
  * `toString: () => string` - Prints out a formatted output of the instance. 

