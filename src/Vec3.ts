// Do not edit this file directly. Edit the template instead: `codegen/templates/vec.eta`.

import { Vec2, Vec4, BVec2, BVec3, BVec4 } from "./";

export class Vec3 {
	constructor(
		public x: number,
		public y: number,
		public z: number,
	) {}

  /** All zeroes. */
	static ZERO = Vec3.splat(0);

	/** All ones. */
	static ONE = Vec3.splat(1);

	/** All negative ones. */
	static NEG_ONE = Vec3.splat(-1);

	/** All `Number.MIN_VALUE`. */
	static MIN = Vec3.splat(Number.MIN_VALUE);

	/** All `Number.MAX_VALUE`. */
	static MAX = Vec3.splat(Number.MAX_VALUE);

	/** All `NaN`. */
	static NAN = Vec3.splat(NaN);

	/** All `Infinity`. */
	static INFINITY = Vec3.splat(Infinity);

	/** All `-Infinity`. */
	static NEG_INFINITY = Vec3.splat(-Infinity);

	/** A unit vector pointing along the positive X axis. */
	static X = new Vec3(1, 0, 0);

	/** A unit vector pointing along the positive Y axis. */
	static Y = new Vec3(0, 1, 0);

	/** A unit vector pointing along the positive Z axis. */
	static Z = new Vec3(0, 0, 1);

	/** A unit vector pointing along the negative X axis. */
	static NEG_X = new Vec3(-1, 0, 0);

	/** A unit vector pointing along the negative Y axis. */
	static NEG_Y = new Vec3(0, -1, 0);

	/** A unit vector pointing along the negative Z axis. */
	static NEG_Z = new Vec3(0, 0, -1);

	/** The unit axes. */
	static AXES = [Vec3.X, Vec3.Y, Vec3.Z];

	/** Creates a vector with all elements set to v. */
	static splat(v: number): Vec3 {
		return new Vec3(v, v, v);
	}

	/**
	 * Creates a vector from the elements in `ifTrue` and `ifFalse`, selecting which to use for each element.
	 * A true element in the mask uses the corresponding element from `ifTrue`, and false uses the element from `ifFalse`.
	 */
	static select(mask: BVec3, ifTrue: Vec3, ifFalse: Vec3): Vec3 {
		return new Vec3(
			mask.test(0) ? ifTrue.x : ifFalse.x,
			mask.test(1) ? ifTrue.y : ifFalse.y,
			mask.test(2) ? ifTrue.z : ifFalse.z,
		);
	}

	/** Creates a new vector from an array. */
	static fromArray(a: [number, number, number]): Vec3 {
		return new Vec3(a[0], a[1], a[2]);
	}

	/** [x, y, z] */
	toArray(): [number, number, number] {
		return [this.x, this.y, this.z];
	}

	/** Creates a `Vec4` vector from `Vec3` and the given `value` value. */
	extend(value: number): Vec4 {
		return new Vec4(this.x, this.y, this.z, value);
	}

	/** Creates a `Vec2` vector from `Vec3` */
	truncate(): Vec2 {
		return new Vec2(this.x, this.y);
	}

	/** Computes the dot product of `Vec3` and `rhs`. */
	dot(rhs: Vec3): number {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	}

	/** Returns a vector where every component is the dot product of `Vec3` and `rhs`. */
	dotIntoVec(rhs: Vec3): Vec3 {
		return Vec3.splat(this.dot(rhs));
	}

	/** Computes the cross product of `Vec3` and `rhs`. */
	cross(rhs: Vec3): Vec3 {
		return new Vec3(
			this.y * rhs.z - this.z * rhs.y,
			this.z * rhs.x - this.x * rhs.z,
			this.x * rhs.y - this.y * rhs.x,
		);
	}

	/** 
	 * Returns a vector containing the minimum values for each element of `Vec3` and `rhs`.
	 * In other words this computes `Math.min(this.x, rhs.x), Math.min(this.y, rhs.y)..`.
	 */
	min(rhs: Vec3): Vec3 {
		return new Vec3(Math.min(this.x, rhs.x), Math.min(this.y, rhs.y), Math.min(this.z, rhs.z));
	}

	/** 
	 * Returns a vector containing the maximum values for each element of `Vec3` and `rhs`.
	 * In other words this computes `Math.max(this.x, rhs.x), Math.max(this.y, rhs.y)..`.
	 */
	max(rhs: Vec3): Vec3 {
		return new Vec3(Math.max(this.x, rhs.x), Math.max(this.y, rhs.y), Math.max(this.z, rhs.z));
	}

	/** Component-wise clamping of values. */
	clamp(min: Vec3, max: Vec3): Vec3 {
		return this.max(min).min(max);
	}

	/** 
	 * Returns the horizontal minimum of `Vec3`.
	 * In other words this computes `Math.min(x, y..)`. 
	 */
	minElement(): number {
		return Math.min(this.x, this.y, this.z);
	}

	/** 
	 * Returns the horizontal maximum of `Vec3`.
	 * In other words this computes `Math.max(x, y, ..)`.
	 */
	maxElement(): number {
		return Math.max(this.x, this.y, this.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `==` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x == rhs.x, this.y == rhs.y..]` for all elements. 
	 */
	cmpeq(rhs: Vec3): BVec3 {
		return new BVec3(this.x === rhs.x, this.y === rhs.y, this.z === rhs.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `!=` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x != rhs.x, this.y != rhs.y..]` for all elements. 
	 */
	cmpne(rhs: Vec3): BVec3 {
		return new BVec3(this.x !== rhs.x, this.y !== rhs.y, this.z !== rhs.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `>=` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x >= rhs.x, this.y >= rhs.y..]` for all elements. 
	 */
	cmpge(rhs: Vec3): BVec3 {
		return new BVec3(this.x >= rhs.x, this.y >= rhs.y, this.z >= rhs.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `>` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x > rhs.x, this.y > rhs.y..]` for all elements. 
	 */
	cmpgt(rhs: Vec3): BVec3 {
		return new BVec3(this.x > rhs.x, this.y > rhs.y, this.z > rhs.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `<=` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x <= rhs.x, this.y <= rhs.y..]` for all elements. 
	 */
	cmple(rhs: Vec3): BVec3 {
		return new BVec3(this.x <= rhs.x, this.y <= rhs.y, this.z <= rhs.z);
	}

	/** 
	 * Returns a vector mask containing the result of a `<` comparison for each element of `Vec3` and `rhs`.
	 * In other words this computes `[this.x < rhs.x, this.y < rhs.y..]` for all elements. 
	 */
	cmplt(rhs: Vec3): BVec3 {
		return new BVec3(this.x < rhs.x, this.y < rhs.y, this.z < rhs.z);
	}

	/** Returns a vector containing the absolute value of each element of `Vec3`. */
	abs(): Vec3 {
		return new Vec3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));
	}

	/** 
	 * Returns a vector with elements representing the sign of `Vec3`.
	 * - `1` if the number is positive, `+0` or `INFINITY`
	 * - `-1` if the number is negative, `-0` or `NEG_INFINITY`	
	 */
	signum(): Vec3 {
		return new Vec3(Math.sign(this.x), Math.sign(this.y), Math.sign(this.z));
	}

	/** 
	 * Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `Vec3`.
	 * A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
	 * into the first lowest bit, element `y` into the second, etc.
	 */
	isNegativeBitmask(): number {
		return (Number(this.x < 0)) | (Number(this.y < 0) << 1) | (Number(this.z < 0) << 2);
	}

	/** Returns `true` if, and only if, all elements are finite. If any element is either `NaN`, positive or negative infinity, this will return `false`. */
	isFinite(): boolean {
		return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.z);
	}

	/** Returns `true` if any elements are `NaN`. */
	isNaN(): boolean {
		return Number.isNaN(this.x) || Number.isNaN(this.y) || Number.isNaN(this.z);
	}

	/** 
	 * Performs `isNaN` on each element of  returning a vector mask of the results.
	 * In other words, this computes `[Number.isNaN(x), Number.isNaN(y)..]`.
	 */
	isNaNMask(): BVec3 {
		return new BVec3(Number.isNaN(this.x), Number.isNaN(this.y), Number.isNaN(this.z));
	}

	/** Computes the length of `Vec3`. */
	length(): number {
		return Math.sqrt(this.dot(this));
	}

	/** Computes the squared length of `Vec3`.
	 * This is faster than `length()` as it avoids a square root operation.
	 */
	lengthSquared(): number {
		return this.dot(this);
	}

	/** 
	 * Computes `1 / length()`.
	 * For valid results, `Vec3` must _not_ be of length zero.
	 */
	lengthRecip(): number {
		return 1 / this.length();
	}

	/** Computes the Euclidean distance between two points in space. */
	distance(rhs: Vec3): number {
		return this.sub(rhs).length();
	}

	/** Compute the squared euclidean distance between two points in space. */
	distanceSquared(rhs: Vec3): number {
		return this.sub(rhs).lengthSquared();
	}

	/** Returns the element-wise quotient of [Euclidean division] of `Vec3` by `rhs`. */
	divEuclid(rhs: Vec3): Vec3 {
		return new Vec3(Math.floor(this.x / rhs.x), Math.floor(this.y / rhs.y), Math.floor(this.z / rhs.z));
	}

	/** Returns the element-wise remainder of [Euclidean division] of `Vec3` by `rhs`. */
	remEuclid(rhs: Vec3): Vec3 {
		return new Vec3(this.x % rhs.x, this.y % rhs.y, this.z % rhs.z);
	}

	/** 
	 * Returns `Vec3` normalized to length 1.
	 * For valid results, `Vec3` must _not_ be of length zero, nor very close to zero.
	 */
	normalize(): Vec3 {
		return this.mul(this.lengthRecip());
	}

	/** 
	 * Returns `Vec3` normalized to length 1 if possible, else returns zero.
	 * In particular, if the input is zero (or very close to zero), or non-finite,
	 * the result of this operation will be zero.
	 */
	normalizeOrZero(): Vec3 {
		const rcp = this.lengthRecip();

		if (Number.isFinite(rcp) && rcp > 0) {
			return this.mul(rcp);
		}

		return Vec3.ZERO;
	}

	/** 
	 * Returns whether `Vec3` is length `1` or not.
	 * Uses a precision threshold of `1e-4`.
	 */
	isNormalized(): boolean {
		return Math.abs(this.lengthSquared() - 1) <= 1e-4;
	}

	/** 
	 * Returns the vector projection of `Vec3` onto `rhs`.
	 * `rhs` must be of non-zero length.
	 */
	projectOnto(rhs: Vec3): Vec3 {
		const otherLenSqRcp = 1 / rhs.dot(rhs);
		return rhs.mul(this.dot(rhs) * otherLenSqRcp);
	}

	/** 
	 * Returns the vector rejection of `Vec3` from `rhs`.
	 * The vector rejection is the vector perpendicular to the projection of `Vec3` onto
	 * `rhs`, in rhs words the result of `Vec3 - this.project_onto(rhs)`.
	 * `rhs` must be of non-zero length.
	 */
	rejectFrom(rhs: Vec3): Vec3 {
		return this.sub(this.projectOnto(rhs));
	}

	/** 
	 * Returns the vector projection of `Vec3` onto `rhs`.
	 * `rhs` must be normalized.
	 */
	projectOntoNormalized(rhs: Vec3): Vec3 {
		return rhs.mul(this.dot(rhs));
	}

	/** 
	 * Returns the vector rejection of `Vec3` from `rhs`.
	 * The vector rejection is the vector perpendicular to the projection of `Vec3` onto
	 * `rhs`, in rhs words the result of `Vec3.sub(this.projectOnto(rhs))`.
	 * `rhs` must be normalized.
	 */
	rejectFromNormalized(rhs: Vec3): Vec3 {
		return this.sub(this.projectOntoNormalized(rhs));
	}

	/** 
	 * Returns a vector containing the nearest integer to a number for each element of `Vec3`.
	 * Round half-way cases away from 0.
	 */
	round(): Vec3 {
		return new Vec3(Math.round(this.x), Math.round(this.y), Math.round(this.z));
	}

	/** 
	 * Returns a vector containing the largest integer less than or equal to a number for each
	 * element of `Vec3`.
	 */
	floor(): Vec3 {
		return new Vec3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
	}

	/** 
	 * Returns a vector containing the smallest integer greater than or equal to a number for
	 * each element of `Vec3`.
	 */
	ceil(): Vec3 {
		return new Vec3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
	}

	/** 
	 * Returns a vector containing the integer part each element of `Vec3`. This means numbers are
	 * always truncated towards zero.
	 */
	trunc(): Vec3 {
		return new Vec3(Math.trunc(this.x), Math.trunc(this.y), Math.trunc(this.z));
	}

	/** 
	 * Returns a vector containing the fractional part of the vector, e.g. `Vec3 -
	 * this.floor()`.
	 * Note that this is fast but not precise for large numbers.
	 */
	fract(): Vec3 {
		return this.sub(this.floor());
	}

	/** Returns a vector containing `e^Vec3` (the exponential function) for each element of `Vec3`. */
	exp(): Vec3 {
		return new Vec3(Math.exp(this.x), Math.exp(this.y), Math.exp(this.z));
	}

	/** Returns a vector containing each element of `Vec3` raised to the power of `n`. */
	powf(n: number): Vec3 {
		return new Vec3(this.x ** n, this.y ** n, this.z ** n);
	}

	/** Returns a vector containing the reciprocal `1/n` of each element of `Vec3`. */
	recip(): Vec3 {
		return new Vec3(1 / this.x, 1 / this.y, 1 / this.z);
	}

	/** 
	 * Performs a linear interpolation between `Vec3` and `rhs` based on the value `s`.
	 * When `s` is `0`, the result will be equal to `Vec3`.  When `s` is `1`, the result
	 * will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
	 * extrapolated.
	 */
	lerp(rhs: Vec3, s: number): Vec3 {
		return this.add(rhs.sub(this).mul(s));
	}

	/** 
	 * Calculates the midpoint between `Vec3` and `rhs`.
	 * The midpoint is the average of, or halfway point between, two vectors.
	 * `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
	 * while being slightly cheaper to compute.
	 */
	midpoint(rhs: Vec3): Vec3 {
		return this.add(rhs).mul(0.5);
	}

	/** 
	 * Returns true if the absolute difference of all elements between `Vec3` and `rhs` is
	 * less than or equal to `maxAbsDiff`.
	 * This can be used to compare if two vectors contain similar elements. It works best when
	 * comparing with a known value. The `maxAbsDiff` that should be used used depends on
	 * the values being compared against.
	 * For more see
	 * [comparing floating point numbers](https:/**randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
	*/
	absDiffEq(rhs: Vec3, maxAbsDiff: number): boolean {
		return this.sub(rhs).abs().cmple(Vec3.splat(maxAbsDiff)).all();
	}

	/** Returns a vector with a length no less than `min` and no more than `max`. */
	clampLength(min: number, max: number): Vec3 {
		const lengthSq = this.lengthSquared();

		if (lengthSq < min * min) {
			return this.div(Math.sqrt(lengthSq)).mul(min);
		}

		if (lengthSq > max * max) {
			return this.div(Math.sqrt(lengthSq)).mul(max);
		}

		return this;
	}

	/** Returns a vector with a length no more than `max`. */
	clampLengthMax(max: number): Vec3 {
		const lengthSq = this.lengthSquared();

		if (lengthSq > max * max) {
			return this.div(Math.sqrt(lengthSq)).mul(max);
		}

		return this;
	}

	/** Returns a vector with a length no less than `min`.  */
	clampLengthMin(min: number): Vec3 {
		const lengthSq = this.lengthSquared();

		if (lengthSq < min * min) {
			return this.div(Math.sqrt(lengthSq)).mul(min);
		}

		return this;
	}

	/** 
	 * Fused multiply-add. Computes `(Vec3 * a) + b` element-wise with only one rounding
	 * error, yielding a more accurate result than an unfused multiply-add.
	 */
	mulAdd(a: Vec3, b: Vec3): Vec3 {
		return this.mul(a).add(b);
	}

	/** 
	 * Returns the angle (in radians) between `Vec3` and `rhs` in the range `[-π, +π]`.
	 * The inputs do not need to be unit vectors however they must be non-zero.
	 */
	angleBetween(rhs: Vec3): number {
		const angle = Math.acos(
			this.dot(rhs) / Math.sqrt(this.lengthSquared() * rhs.lengthSquared()),
		);

		return angle;
	}

	/**
	 * Returns some vector that is orthogonal to the given one.
	 * The input vector must be finite and non-zero.
	 * The output vector is not necessarily unit length. For that use [`anyOrthonormalVector()`] instead.
	 */
	anyOrthogonalVector() {
		if (Math.abs(this.x) > Math.abs(this.y)) {
			return new Vec3(-this.z, 0, this.x);
		}

		return new Vec3(0, this.z, -this.y);
	}

	/** 
	 * Returns any unit vector that is orthogonal to the given one.
	 * The input vector must be unit length.
	 */
	anyOrthonormalVector() {
		// From https://graphics.pixar.com/library/OrthonormalB/paper.pdf
		const sign = Math.sign(this.z);
		const a = -1 / (sign + this.z);
		const b = this.x * this.y * a;
		return new Vec3(b, sign + this.y * this.y * a, -this.y);
	}

	/** 
	 * Given a unit vector return two other vectors that together form an orthonormal
	 * basis. That is, all three vectors are orthogonal to each other and are normalized.
	 */
	anyOrthonormalPair() {
		// From https://graphics.pixar.com/library/OrthonormalB/paper.pdf
		const sign = Math.sign(this.z);
		const a = -1 / (sign + this.z);
		const b = this.x * this.y * a;

		return [
			new Vec3(1 + sign * this.x * this.x * a, sign * b, -sign * this.x),
			new Vec3(b, sign + this.y * this.y * a, -this.y),
		];
	}

	/** 
	 * Divides a Vec3 by another Vector, or by a number
	 * (this.x / rhs.x, this.y / rhs.y) or (this.x / rhs, this.y / rhs).
	 */
	div(rhs: Vec3 | number): Vec3 {
		if (rhs instanceof Vec3) {
			return new Vec3(this.x / rhs.x, this.y / rhs.y, this.z / rhs.z);
		}

		return new Vec3(this.x / rhs, this.y / rhs, this.z / rhs);
	}

	/**
	 * Multiplies a Vec3 by another Vector, or by a number
	 * (this.x * rhs.x, this.y * rhs.y..) or (this.x * rhs, this.y * rhs..).
	 */
	mul(rhs: Vec3 | number): Vec3 {
		if (rhs instanceof Vec3) {
			return new Vec3(this.x * rhs.x, this.y * rhs.y, this.z * rhs.z);
		}

		return new Vec3(this.x * rhs, this.y * rhs, this.z * rhs);
	}

	/** 
	 * Sums a Vec3 by another Vector, or by a number
	 * (this.x + rhs.x, this.y + rhs.y..) or (this.x + rhs, this.y + rhs..)
	 */
	add(rhs: Vec3 | number): Vec3 {
		if (rhs instanceof Vec3) {
			return new Vec3(this.x + rhs.x, this.y + rhs.y, this.z + rhs.z);
		}

		return new Vec3(this.x + rhs, this.y + rhs, this.z + rhs);
	}

	/**
	 * Subtracts a Vec3 by another Vector, or by a number
	 * (this.x - rhs.x, this.y - rhs.y..) or (this.x - rhs, this.y - rhs..)
	 */
	sub(rhs: Vec3 | number): Vec3 {
		if (rhs instanceof Vec3) {
			return new Vec3(this.x - rhs.x, this.y - rhs.y, this.z - rhs.z);
		}

		return new Vec3(this.x - rhs, this.y - rhs, this.z - rhs);
	}

	/**
	 * Divides a Vec3 by another Vector, or by a number and return its remainder
	 * (this.x % rhs.x, this.y % rhs.y..) or (this.x % rhs, this.y % rhs..)
	 */
	rem(rhs: Vec3 | number): Vec3 {
		if (rhs instanceof Vec3) {
			return new Vec3(this.x % rhs.x, this.y % rhs.y, this.z % rhs.z);
		}

		return new Vec3(this.x % rhs, this.y % rhs, this.z % rhs);
	}

	/** Returns (-this.x, -this.y..) */
	neg(): Vec3 {
		return new Vec3(-this.x, -this.y, -this.z);
	}

	/** Compares if the vector is equal to another. */
	eq(rhs: Vec3 | number): boolean {
		if (rhs instanceof Vec3) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		}

		return this.x === rhs && this.y === rhs && this.z === rhs;
	}

	/** Compares if the vector is not equal to another. */
	ne(rhs: Vec3 | number): boolean {
		if (rhs instanceof Vec3) {
			return this.x !== rhs.x || this.y !== rhs.y || this.z !== rhs.z;
		}

		return this.x !== rhs || this.y !== rhs || this.z !== rhs;
	}

	/** Compares if the vector is approximately equal to another, by the threshold of 1e-6. */
	approxEq(rhs: Vec3 | number): boolean {
		const threshold = 1e-6;

		if (rhs instanceof Vec3) {
			return Math.abs(this.x - rhs.x) < threshold && Math.abs(this.y - rhs.y) < threshold && Math.abs(this.z - rhs.z) < threshold;
		}

		return Math.abs(this.x - rhs) < threshold && Math.abs(this.y - rhs) < threshold && Math.abs(this.z - rhs) < threshold;
	}

	/** Applies a swizzle to the vector. Example: "v0._`xyxy` => Vec4(this.x, this.y, this.x, this.y)" */
	_(value: TemplateStringsArray): Vec2 | Vec3 | Vec4 {
		const properties = ["x", "y", "z", "w"];
		const params = value[0].trim().split("");
		const values = [this.x, this.y, this.z];

		if (params.some((param) => !properties.slice(0, 3).includes(param))) {
			throw new Error("Invalid parameters. Only [x, y, z] are allowed.");
		}

		const coordinates = params.map(
			(param) => values[properties.indexOf(param)],
		);

		switch (params.length) {
			case 2:
				return new Vec2(coordinates[0], coordinates[1]);
			case 3:
				return new Vec3(coordinates[0], coordinates[1], coordinates[2]);
			case 4:
				return new Vec4(
					coordinates[0],
					coordinates[1],
					coordinates[2],
					coordinates[3],
				);
			default:
				throw new Error("Invalid number of parameters.");
		}
	}
}
